<?php
/**
 * This file contains a class to generate and validate serial numbers.
 *
 * This class is an improved version of the class 'license' found at
 * http://www.phpclasses.org/package/6690-PHP-Generate-and-validate-license-serial-numbers.html .
 * The original autor is Payam khaninajad <Progvig@yahoo.com>.
 * @version 0.1
 * @package Scripts
 */

/**
 * This class can generate and validate serial numbers based on values given by
 * the user.
 *
 * Serial numbers generated by this class cannot be reversed.
 * @author Diego Andrade <diegohdk@gmail.com>
 * @package Scripts
 * @version 0.1
 * @since 02/03/2011
 */
class Serial
{
	/**
	 * Length of the serial generated by this class.
	 *
	 * This length does not include the dashes "-".
	 * @var int
	 */
	private $length = null;

	/**
	 * Creates a new instance of the class to generate and validate serial
	 * numbers.
	 *
	 * The serial number generated by this class is a string that includes only
	 * numbers and letters. The serial number is arranged in 4 groups and these
	 * groups are separated by dashes "-".
	 *
	 * The number of elements (numbers and letters) in each group is defined by
	 * the $length parameter. By default the length is 10, which means that each
	 * group has 10 elements and the final serial has 40 elements (excluding the
	 * dashes).
	 *
	 * The maximum value for the length is 10. If a value greater then 10 or
	 * less then 0 is given, and exception is thrown.
	 *
	 * The length can not be changed after the class initialization.
	 * @param int $length (optimal) Number of elements in each group of the
	 * serial. Must be between 1 and 10. Any other value will throw an
	 * exception. Default is 10.
	 */
	public function __construct($length = 10)
	{
		if(($length > 0) && ($length <= 10))
			$this->length = $length;
		else
			throw new Exception('Invalid length');
	}


	/**
	 * Generates the serial number based on an input value.
	 * @param string $input (optimal) A base value used to generate the serial
	 * number. If this parameter is not omitted, then the current timestamp will
	 * be used to generate the input string.
	 * @return string
	 */
	public function generate($input = null)
	{
		// check to see if we have some input string
		if(is_null($input))
			$input = uniqid(microtime(), true);

		// first we encode the input string with the sha1 algorithm.
		$encodedInput = sha1($input);

		// our secret is the ASCII value of the first digit
		$secret = ord($input{0});

		// and we define some commom variables
		$serial = array();
		$blockSize = $this->length;
		$blockCount = -1;

		// loop the four main blocks of the serial
		while(++$blockCount < 4)
		{
			// our initial blocks will be retrived from the encoded string
			$block = substr($encodedInput, ($blockCount * $blockSize), $blockSize);
			$ascii = array();

			// we get the ASCII codes from each digit in the block and add the
			// secret
			for($i = 0; $i < strlen($block); $i++)
				$ascii[] = $secret + ord($block{$i});

			// now we limit the ASCII array to 20 numbers
			$ascii = array_slice($ascii, 0, 20);
			$serialPart = '';

			// loop through the ASCII array
			foreach($ascii as $numbers)
			{
				switch($numbers)
				{
					case $numbers > 122:
						$numbers -= 40;
						break;
					case $numbers <= 48:
						$numbers += 40;
						break;
				}

				// we get the ASCII character from the new ASCII code
				$serialPart .= chr($numbers);
			}

			// new that we have the ASCII string, we encode it with the MD5
			// algorithm
			$serialPart = md5($serialPart);
			$finalSerialPart = '';
			$x = -1;

			// loop 'till the block size to get the digits from the MD5 string
			while(++$x < $blockSize)
			{
				// our index will be the current position in the string
				// multiplied by the number of the current block plus 1
				$index = $x * ($blockCount + 1);

				// if the index is greater then the string length, we
				// recalculate using two blocks before to avoid errors with the
				// offset
				if($index >= strlen($serialPart))
					$index = $x * (($blockCount / 2) + 1);

				$finalSerialPart .= $serialPart{$index};
			}

			// we add the final block string to the serial's array
			$serial[$blockCount] = $finalSerialPart;
		}

		// we return the final string separated by dashes
		return implode('-', $serial);
	}

	/**
	 * Checks whether the given serial was generated with the given input
	 * string.
	 *
	 * Returns true if the resulting serial number of the input string matches
	 * the serial given, or false otherwise.
	 * @param string $serial Serial number.
	 * @param string $input Input string.
	 * @return bool
	 */
	public function validate($serial, $input)
	{
		return strcmp($this->generate($input), $serial) === 0;
	}
}
?>